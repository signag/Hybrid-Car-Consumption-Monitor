[{"apiVersion":"influxdata.com/v2alpha1","kind":"Task","metadata":{"name":"burfect-poitras-31b001"},"spec":{"every":"5m","name":"HCCM_EnergyCharged","query":"//=============================================================================================================\n// This function calculates the energy charged through the charging device\n// The energy will increase from zero after each charging cycle\n// When the charging cycle has finished it will fall to zero\n//\n// This is limited to a single car, for which the Vehicle Identification Number\n// and capacity must be spezified below\n//=============================================================================================================\n\n\n// !!! XXXXXXXXXXXXXXXXX ! Specify Vecicle Identification Number here !!!!!!!!!!!!!!!!!\nvin = \"XXXXXXXXXXXXXXXXX\"\n\ntStart = -1d\ntStop = now()\n\nchrg1 =\n    from(bucket: \"Car_Charging\")\n        // Get the energy captured for the Fritz! HA device used for charging\n        |> range(start: tStart, stop: tStop)\n        |> filter(fn: (r) => r[\"_measurement\"] == \"energy\")\n        |> filter(fn: (r) => r[\"sublocation\"] == vin)\nchrg2 =\n    chrg1\n        // Keep only columns required for this analysis\n        |> drop(columns: [\"_measurement\", \"_start\", \"_stop\"])\n        // Sort with respect to _time to avoid issues with derivative\n        |> sort(columns: [\"_time\"])\nchrg3 =\n    chrg2\n        // We are not interested in absolute overall values but only in relative increments\n        |> increase()\n        // Now, we differentiate the energy to get the power\n        |> duplicate(column: \"_value\", as: \"power\")\n        |> derivative(unit: 1h, columns: [\"power\"])\nchrg4 =\n    chrg3\n        // Measuring points indication zero power can be excluded\n        |> filter(fn: (r) => r[\"power\"] > 0)\n        // Now, we define a step function (tag) on the power, setting all values below a threshold to zero.\n        |> map(fn: (r) => ({r with tag: if r.power > 0.08 then 1 else 0}))\n        // Now, we identify instances of rising and falling power\n        // tag2 ==  1: rising power\n        // tag2 ==  0: steady power level\n        // tag2 == -1: falling power\n        |> duplicate(column: \"tag\", as: \"tag2\")\n        |> difference(columns: [\"tag2\"], nonNegative: false, keepFirst: true, initialZero: true)\n        // Now, we use tag3, to identify all measuring points, related to a charging period\n        // This needs to include the starting point (tag2 == 1) and the end point (tag2 == -1)\n        // as well as all points with sufficiently high power level (tag == 1)\n        |> map(fn: (r) => ({r with tag3: if r.tag2 == -1 then 1 else r.tag}))\nchrg5 =\n    chrg4\n        // Now, we keep only the charging periods (tag3 == 1)\n        |> filter(fn: (r) => r[\"tag3\"] == 1)\n        // Now, we define tag4, which identifies all starting points of charging periods\n        |> map(fn: (r) => ({r with tag4: if r.tag2 == 1 then 1 else 0}))\n        // When accumulating tag4 in tag5, every charging period gets its individual value\n        // because onty the starting points contribute whereas assl subsequent points of the same period don't\n        |> duplicate(column: \"tag4\", as: \"tag5\")\n        |> cumulativeSum(columns: [\"tag5\"])\nchrg6 =\n    chrg5\n        // This allows grouping with respect to charging periods\n        |> group(columns: [\"tag5\"])\n        // Cumulative sum of tag will count the measuring points of a period\n        // Cumulative sum of tag4 (1 only for starting points) will indicate whether a sequence is complete\n        // If a sequence does not include the starting point the sum will remain zero.\n        |> cumulativeSum(columns: [\"tag\", \"tag4\"])\nchrg7 =\n    chrg6\n        // Now, we keep only complete charging periods (tag4 == 1)\n        |> filter(fn: (r) => r[\"tag4\"] == 1)\n        // We are not interested in absolute overall values but only in relative increments\n        |> increase(columns: [\"_value\"])\nchrg8 =\n    chrg7\n        // Now, we set the energy to 0 for the last point of each complete charging period\n        |> map(fn: (r) => ({r with _value: if r.tag2 == -1 then 0.0 else r._value}))\n        // Drop all unnecessary columns\n        |> drop(\n            columns: [\n                \"power\",\n                \"tag\",\n                \"tag2\",\n                \"tag3\",\n                \"tag4\",\n                \"tag5\",\n            ],\n        )\n        // Add columns required for the bucket\n        |> set(key: \"_measurement\", value: \"charged\")\n\nchrg8\n    |> to(\n        bucket: \"Car_Charging\",\n        timeColumn: \"_time\",\n        measurementColumn: \"_measurement\",\n        tagColumns: [\"ain\", \"location\", \"sublocation\", \"state\"],\n        fieldFn: (r) => ({\"value\": r._value}),\n    )"}}]