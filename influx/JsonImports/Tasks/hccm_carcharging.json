[{"apiVersion":"influxdata.com/v2alpha1","kind":"Task","metadata":{"name":"affectionate-lamport-b5c001"},"spec":{"every":"5m0s","name":"HCCM_CarCharging","query":"//=============================================================================================================\n// This function analyzes the energy for car charging to identify individual charging processes\n// For each charging process, a measurement entry is made in bucket Car_Consumption\n// In order to assure that this is done only after a charging process has been finished,\n// the drop of charging power is sensed\n//\n// This is limited to a single car, for which the Vehicle Identification Number must be spezified below\n//=============================================================================================================\nimport \"timezone\"\nimport \"date\"\nimport \"array\"\n\n\n\noption location = timezone.location(name: \"Europe/Berlin\")\n\n// !!! XXXXXXXXXXXXXXXXX ! Specify Vecicle Identification Number here !!!!!!!!!!!!!!!!!\nvin = \"?????????????????\"\n\n// For testing purposes, tStop may be set to a time shortly after a charging process has ended\n//tStop = 2023-03-22T12:30:00Z\ntStop = now()\n\n// This is the period used for sensing power drop for charging\n// It must be at least twice the sampling period used for device measurements\n// It must be less than the shortest possibe charging duration\nperiodSensing = 20m\n\n// This is the period used for gathering charging processes\nperiodProcesses = 2d\n\n// This is the threshold used for sensing the end of a charging process.\n// Typically half the charging power (~2 kW)\nchargingThreshold = 1000\n\n// ===================================================================================================\n// This function checks whether the chosen stop time is after the end of a charging period\n// ===================================================================================================\nchargingFinished = () => {\n    tStart = date.sub(from: tStop, d: periodSensing)\n\n    powerData =\n        from(bucket: \"Car_Charging\")\n            |> range(start: tStart, stop: tStop)\n            |> filter(fn: (r) => r[\"_measurement\"] == \"power\")\n            |> filter(fn: (r) => r[\"sublocation\"] == vin)\n\n    powerDataFirst =\n        powerData\n            |> first()\n    powerDataFirstRec =\n        powerDataFirst\n            |> findRecord(\n                fn: (key) => key._measurement == \"power\" and key._field == \"value\",\n                idx: 0,\n            )\n    p0 = powerDataFirstRec[\"_value\"]\n\n    powerDataLast =\n        powerData\n            |> last()\n    powerDataLastRec =\n        powerDataLast\n            |> findRecord(\n                fn: (key) => key._measurement == \"power\" and key._field == \"value\",\n                idx: 0,\n            )\n    p1 = powerDataLastRec[\"_value\"]\n\n    ret = if p0 > chargingThreshold and p1 < chargingThreshold then true else false\n\n    return ret\n}\n\n// ===================================================================================================\n// Analyze the charged energy to identify the different charging events\n// Start of a charging event is identified by steeply rising power\n// End of the charing event is identified by steeply decreasing power\n// ===================================================================================================\nconsumptionFromCharging =\n    () =>\n        {\n            tStart = date.sub(from: tStop, d: periodProcesses)\n\n            calc =\n                from(bucket: \"Car_Charging\")\n                    // Get the energy captured for the Fritz! HA device used for charging\n                    |> range(start: tStart, stop: tStop)\n                    |> filter(fn: (r) => r[\"_measurement\"] == \"energy\")\n                    |> filter(fn: (r) => r[\"sublocation\"] == vin)\n                    // Keep only columns required for this analysis\n                    |> drop(\n                        columns: [\n                            \"_measurement\",\n                            \"ain\",\n                            \"location\",\n                            \"state\",\n                            \"sublocation\",\n                            \"_start\",\n                            \"_stop\",\n                        ],\n                    )\n                    // Sort with respect to _time to avoid issues with derivative\n                    |> sort(columns: [\"_time\"])\n                    // We are not interested in absolute overall values but only in relative increments\n                    |> increase()\n                    // Now, we differentiate the energy to get the power\n                    |> duplicate(column: \"_value\", as: \"diff\")\n                    |> derivative(unit: 1h, columns: [\"diff\"])\n                    // Measuring points indication zero power can be excluded\n                    |> filter(fn: (r) => r[\"diff\"] > 0)\n                    // Now, we define a step function (tag) on the power, setting all values below a threshold to zero.\n                    |> map(fn: (r) => ({r with tag: if r.diff > 0.08 then 1 else 0}))\n                    // Now, we identify instances of rising and falling power\n                    // tag2 ==  1: rising power\n                    // tag2 ==  0: steady power level\n                    // tag2 == -1: falling power\n                    |> duplicate(column: \"tag\", as: \"tag2\")\n                    |> difference(\n                        columns: [\"tag2\"],\n                        nonNegative: false,\n                        keepFirst: true,\n                        initialZero: true,\n                    )\n                    // Now, we use tag3, to identify all measuring points, related to a charging period\n                    // This needs to include the starting point (tag2 == 1) and the end point (tag2 == -1)\n                    // as well as all points with sufficiently high power level (tag == 1)\n                    |> map(fn: (r) => ({r with tag3: if r.tag2 == -1 then 1 else r.tag}))\n                    // Now, we keep only the charging periods (tag == 1)\n                    |> filter(fn: (r) => r[\"tag3\"] == 1)\n                    // Now, we define tag4, which identifies all starting points of charging periods\n                    |> map(fn: (r) => ({r with tag4: if r.tag2 == 1 then 1 else 0}))\n                    // When accumulating tag4 in tag5, every charging period gets its individual value\n                    // because onty the starting points contribute whereas assl subsequent points of the same period don't\n                    |> duplicate(column: \"tag4\", as: \"tag5\")\n                    |> cumulativeSum(columns: [\"tag5\"])\n                    // This allows grouping with respect to charging periods\n                    |> group(columns: [\"tag5\"])\n                    // Cumulative sum of tag will count the measuring points of a period\n                    // Cumulative sum of tag4 (1 only for starting points) will indicate whether a sequence is complete\n                    // If a sequence does not include the starting point the sum will remain zero.\n                    |> cumulativeSum(columns: [\"tag\", \"tag4\"])\n                    // Only the last row in each table is kept which carries the energy carged during a charging period\n                    // and the sum of measurement points (tag).\n                    // The value of tag4 indicates whether a series is complete (1) or incomplete (0)\n                    // because the value of 1 is only possible if a series includes a starting mark (tag2==1) for rising power\n                    |> tail(n: 1)\n                    // Now ungroup stream to get a single table\n                    |> group()\n                    // Now, we keep only the rows for suffinciently long charging periods (tag > 3)\n                    |> filter(fn: (r) => r[\"tag\"] > 3)\n                    // _value contains the energy, charged at a certain time\n                    |> duplicate(column: \"_value\", as: \"charged\")\n                    // The energy, charged in a specific charging period is the difference between subsequent rows\n                    |> difference(\n                        columns: [\"charged\"],\n                        nonNegative: false,\n                        keepFirst: true,\n                        initialZero: true,\n                    )\n                    |> map(\n                        fn: (r) =>\n                            ({r with charged: if r.charged == 0 then r._value else r.charged}),\n                    )\n                    // Now, we keep only the rows for complete charging periods (tag4 == 1)\n                    |> filter(fn: (r) => r[\"tag4\"] == 1)\n                    // Drop all unnecessary columns\n                    |> drop(\n                        columns: [\n                            \"_value\",\n                            \"_field\",\n                            \"diff\",\n                            \"tag\",\n                            \"tag2\",\n                            \"tag3\",\n                            \"tag4\",\n                            \"tag5\",\n                        ],\n                    )\n                    // Add columns required for the bucket\n                    |> set(key: \"_measurement\", value: \"consumption\")\n                    |> set(key: \"process\", value: \"charge\")\n                    |> set(key: \"source\", value: \"CarCharger\")\n                    |> set(key: \"vin\", value: vin)\n                    |> set(key: \"tag\", value: \"CALC\")\n\n            // To avoid duplicates, we check existing consumption entries\n            cons =\n                from(bucket: \"Car_Consumption\")\n                    // Get all KFZ_Consumption entries within the range, representing charging events\n                    // (_field == \"energy\" AND source == \"home\")\n                    |> range(start: tStart, stop: tStop)\n                    |> filter(fn: (r) => r[\"_measurement\"] == \"consumption\")\n                    |> filter(fn: (r) => r[\"_field\"] == \"energy\")\n                    |> filter(fn: (r) => r[\"source\"] == \"CarCharger\")\n                    |> duplicate(column: \"_value\", as: \"charged\")\n                    // Drop unnecessary columns\n                    |> drop(columns: [\"_start\", \"_stop\", \"_value\", \"_field\"])\n                    |> set(key: \"tag\", value: \"CONS\")\n\n            uni =\n                // Union streams with new and existing charging events\n                union(tables: [calc, cons])\n\n            unis =\n                uni\n                    // Ungroup to get all in a single table\n                    |> group()\n                    // Sort with respect to _time to get the correct sequence of new and existing charging events\n                    |> sort(columns: [\"_time\"])\n\n            unisf =\n                unis\n                    // We need to preserve the first record ecause elapsed will remove it\n                    |> first(column: \"source\")\n                    |> map(fn: (r) => ({r with tdiff: 0}))\n\n            uniel =\n                unis\n                    // Add column for time elapsed between events\n                    |> elapsed(unit: 1m, columnName: \"tdiff\")\n\n            unin =\n                // Include the first record\n                union(tables: [unisf, uniel])\n\n            unins =\n                unin\n                    // Sort\n                    |> sort(columns: [\"_time\"])\n\n            uninsg =\n                unins\n                    // Add tag2 for later grouping of entries within the same interval\n                    |> map(fn: (r) => ({r with tag2: if r.tdiff > 20 then 1 else 0}))\n                    // Add counter column\n                    |> map(fn: (r) => ({r with count: 1}))\n                    // cumulating sum will give the key for subsequent grouping\n                    |> cumulativeSum(columns: [\"tag2\"])\n                    // This allows grouping with respect to intervals\n                    |> group(columns: [\"tag2\"])\n                    // cumulate counter to find groups with multiple records\n                    |> cumulativeSum(columns: [\"count\"])\n\n            uninsgt =\n                uninsg\n                    // Keep just the last row\n                    |> tail(n: 1)\n                    // Ungroup\n                    |> group()\n\n            ret =\n                uninsgt\n                    // Now, filter just rows resulting from groups with a single calculated entry\n                    |> filter(fn: (r) => r[\"count\"] == 1 and r[\"tag\"] == \"CALC\")\n                    // Drop unnecessary columns\n                    |> drop(columns: [\"tag\", \"tdiff\", \"tag2\", \"count\"])\n\n            return ret\n        }\n\n// ===================================================================================================\n// Start main program\n// ===================================================================================================\ncf = chargingFinished()\n\n// Define a default array which is to be used if the chosen stop time is not after the end of a charging period\nconsNul =\n    array.from(\n        rows: [\n            {\n                _time: 1900-01-01T00:00:00Z,\n                _measurement: \"consumption\",\n                process: \"charge\",\n                source: \"CarCharger\",\n                vin: \"000000000000\",\n                charged: 0.0,\n            },\n        ],\n    )\n\n// Determine energy consumption from charging periods\n// only if the end of a charging period has been sensed\ncons = if chargingFinished() then consumptionFromCharging() else consNul\n\ncons\n    |> to(\n        bucket: \"Car_Consumption\",\n        timeColumn: \"_time\",\n        measurementColumn: \"_measurement\",\n        tagColumns: [\"process\", \"source\", \"vin\"],\n        fieldFn: (r) => ({\"energy\": r.charged}),\n    )"}}]