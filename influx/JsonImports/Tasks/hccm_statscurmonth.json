[{"apiVersion":"influxdata.com/v2alpha1","kind":"Task","metadata":{"name":"mystifying-clarke-9ea001"},"spec":{"every":"1h","name":"HCCM_StatsCurMonth","query":"//=========================================================================================\n// This program calculates monthly statistics\n//\n// This is limited to a single car, for which the Vehicle Identification Number must be spezified below\n//=========================================================================================\nimport \"timezone\"\nimport \"date\"\nimport \"array\"\nimport \"experimental/date/boundaries\"\n\n\n\noption location = timezone.location(name: \"Europe/Berlin\")\n\n// !!! XXXXXXXXXXXXXXXXX ! Specify Vecicle Identification Number here !!!!!!!!!!!!!!!!!\nvin = \"XXXXXXXXXXXXXXXXX\"\n\ncurMonth = boundaries.month(month_offset: 0)\n\n//=========================================================================================\n// check whether table has been dropped\n// From https://medium.com/@marcodb.dev/flux-checking-for-empty-and-dropped-tables-f36134b3cd26\n//=========================================================================================\nisDropped = (tables) => {\n    columnsArray =\n        tables\n            |> columns()\n            |> findColumn(fn: (key) => true, column: \"_value\")\n\n    return length(arr: columnsArray) == 0\n}\n\n//=========================================================================================\n// check whether table has been dropped or is empty\n// From https://medium.com/@marcodb.dev/flux-checking-for-empty-and-dropped-tables-f36134b3cd26\n//=========================================================================================\nisDroppedOrEmpty = (tables, column) => {\n    cntArray =\n        tables\n            |> count(column: column)\n            |> findColumn(fn: (key) => true, column: column)\n\n    return\n        if length(arr: cntArray) == 0 then\n            true\n        else if cntArray[0] == 0 then\n            true\n        else\n            false\n}\n\n//=========================================================================================\n// nullRec is used in cases where a result record cannot be found because source table is dropped or empty\n//=========================================================================================\nnullRec = {\n    _time: 1900-01-01T00:00:00Z,\n    _measurement: \"null\",\n    label: \"null\",\n    _value: 0,\n    count: 0,\n    tripMileage: 0,\n    traveltime: 0,\n    fuelConsumed: 0.0,\n    electricEnergyConsumed: 0.0,\n    electricEnergyCharged: 0.0,\n    type: \"null\",\n    tripCount: 0,\n}\n\n//=========================================================================================\n// Check whether trips exist for the intended range\n//=========================================================================================\ntripsTest =\n    from(bucket: \"Car_Trips\")\n        |> range(start: curMonth.start, stop: curMonth.stop)\n        |> filter(onEmpty: \"drop\", fn: (r) => r._measurement == \"trip_shortTerm\" and r.vin == vin)\n\ntripsExist = not isDropped(tables: tripsTest)\n\n//==================================================================================================\n// Evaluate overall trip-related data\n//==================================================================================================\ntripsAll =\n    from(bucket: \"Car_Trips\")\n        // Get all short term trips within range\n        |> range(start: curMonth.start, stop: curMonth.stop)\n        |> filter(fn: (r) => r[\"_measurement\"] == \"trip_shortTerm\")\n        |> filter(fn: (r) => r[\"vin\"] == vin)\n        // Drop unnecessary columns\n        |> drop(\n            columns: [\n                \"_measurement\",\n                \"_start\",\n                \"_stop\",\n                \"reportReason\",\n                \"tripID\",\n            ],\n        )\n        // Pivot with respect to _time to get a table with rows based on _time and data as columns\n        |> pivot(rowKey: [\"_time\"], columnKey: [\"_field\"], valueColumn: \"_value\")\n        // Sorting the table with respect to _time is essential because Influx does not sort automatically\n        |> sort(columns: [\"_time\"])\n        //Rename \"electricPowerConsumed\" to \"electricEnergyConsumed\"\n        |> duplicate(column: \"electricPowerConsumed\", as: \"electricEnergyConsumed\")\n        |> drop(columns: [\"electricPowerConsumed\"])\n        // The Car_Trips bucket includes all partial trips for which data are accumulated into the latest.\n        // Whereas WeConnect finally keeps only the latest trip of a group, we also keep the partial trips\n        // as long as they have been received from WeConnect before the entire trip has been \"closed\"\n        // by a gap of at least 2 hours\n        // All partial trips of a trip have the same \"startMileage\"\n        // We only need to keep the last one\n        |> group(columns: [\"startMileage\"])\n        |> tail(n: 1)\n        |> group()\n        // Add column for counting the trips\n        |> map(fn: (r) => ({r with count: 1}))\n\nmonthDataTotal =\n    tripsAll\n        // Accumulate relevant data rowwise\n        |> cumulativeSum(\n            columns: [\n                \"electricEnergyConsumed\",\n                \"fuelConsumed\",\n                \"traveltime\",\n                \"tripMileage\",\n                \"count\",\n            ],\n        )\n        // Keep the last row to get monthly sums\n        |> last(column: \"tripMileage\")\n        // Group to provide the key for later tableFind\n        |> group(columns: [\"vin\"])\n\nmonthDataTotalRec =\n    if tripsExist then\n        monthDataTotal\n            // Extract table from stream\n            |> tableFind(fn: (key) => key.vin == vin)\n            // Extract row from table\n            |> getRecord(idx: 0)\n    else\n        // Set result to nullRecord in case no data were found\n        nullRec\n\n// Extract statistics data from sum record\ntime = curMonth.stop\nmeasurement = \"statistics\"\ntripsTotal = if tripsExist then monthDataTotalRec[\"count\"] else 0\nmileageTotal = if tripsExist then monthDataTotalRec[\"tripMileage\"] else 0\ntraveltimeTotal = if tripsExist then monthDataTotalRec[\"traveltime\"] else 0\nfuelConsumed = if tripsExist then float(v: monthDataTotalRec[\"fuelConsumed\"]) else 0.0\nelectricEnergyConsumedTotal =\n    if tripsExist then float(v: monthDataTotalRec[\"electricEnergyConsumed\"]) else 0.0\n\n//==================================================================================================\n// Evaluate trip-related data for purely electric trips\n//==================================================================================================\ntripsEl =\n    tripsAll\n        // Keep only trips for which no fuel was consumed\n        // Sometimes short trips with mileage 0 are registered. These must be excluded\n        |> filter(fn: (r) => r[\"fuelConsumed\"] == 0 and r[\"tripMileage\"] > 0)\n\nmonthDataEl =\n    tripsEl\n        // Accumulate relevant data rowwise\n        |> cumulativeSum(columns: [\"electricEnergyConsumed\", \"traveltime\", \"tripMileage\", \"count\"])\n        // Keep the last row to get monthly sums\n        |> last(column: \"tripMileage\")\n        // Group to provide the key for later tableFind\n        |> group(columns: [\"vin\"])\n\n// Check whether monthly data for purely electric trips exist\nmonthDataElExist = if not tripsExist then false else not isDropped(tables: monthDataEl)\n\nmonthDataElRec =\n    if monthDataElExist then\n        monthDataEl\n            // Extract table from stream\n            |> tableFind(fn: (key) => key.vin == vin)\n            // Extract row from table\n            |> getRecord(idx: 0)\n    else\n        // Set result to nullRecord in case no data were found\n        nullRec\n\n// Extract statistics data from sum record\ntripsElectric = if monthDataElExist then monthDataElRec[\"count\"] else 0\nmileageElectric = if monthDataElExist then monthDataElRec[\"tripMileage\"] else 0\ntraveltimeElectric = if monthDataElExist then monthDataElRec[\"traveltime\"] else 0\nelectricEnergyConsumedElectric =\n    if monthDataElExist then float(v: monthDataElRec[\"electricEnergyConsumed\"]) else 0.0\n\n//==================================================================================================\n// Evaluate statistics data for all charging cycles\n//==================================================================================================\nchrgMonth =\n    from(bucket: \"Car_Consumption\")\n        // Get all Car_Consumption entries within the range, representing charging events\n        // (_field == \"energy\" AND source == \"home\")\n        |> range(start: curMonth.start, stop: curMonth.stop)\n        |> filter(fn: (r) => r[\"_measurement\"] == \"consumption\")\n        |> filter(fn: (r) => r[\"vin\"] == vin)\n        |> filter(fn: (r) => r[\"_field\"] == \"energy\")\n        |> filter(fn: (r) => r[\"process\"] == \"charge\")\n        // Drop unnecessary columns\n        |> drop(\n            columns: [\n                \"_measurement\",\n                \"_start\",\n                \"_stop\",\n                \"process\",\n                \"source\",\n                \"vin\",\n            ],\n        )\n        // Add column for counting the charging events\n        |> map(fn: (r) => ({r with count: 1}))\n\nchrgTotal =\n    chrgMonth\n        // Sum up charged energy (_value) and number of charging events\n        |> cumulativeSum(columns: [\"_value\", \"count\"])\n        // Keep the last row to get monthly sums\n        |> last(column: \"count\")\n        // Group to provide the key for later tableFind\n        |> group(columns: [\"_field\"])\n\n// Check whether charging events exist within the given range\nchrgTotalExist = if not tripsExist then false else not isDropped(tables: chrgTotal)\n\nchrgTotalRec =\n    if chrgTotalExist then\n        chrgTotal\n            // Extract table from stream\n            |> tableFind(fn: (key) => key._field == \"energy\")\n            // Extract row from table\n            |> getRecord(idx: 0)\n    else\n        // Set result to nullRecord in case no data were found\n        nullRec\n\n// Extract statistics data from sum record\nchargeCyclesTotal = if chrgTotalExist then chrgTotalRec[\"count\"] else 0\nelectricEnergyChargedTotal = if chrgTotalExist then float(v: chrgTotalRec[\"_value\"]) else 0.0\n\n//==================================================================================================\n// Evaluate data for charging cycles related to purely electric trips\n// This requires a separate step because a single charging event may be related to multiple trips\n// where one or more may have required fuel.\n// So, we need to restrict trips and charging events to those situations where all trips previous\n// to a charging event were purely electric\n// This will be the basis for calculating statistical consumption data for purely electric trips\n//\n// The basis for this evaluation will be a union of a table of trips data with a table of charging events\n// From the resulting table, only those groups of trips and related charging event will be kept\n// for which no fuel has been consumed\n//==================================================================================================\ntripsAllEl =\n    // first create a table of trips, starting from all trips\n    tripsAll\n        // Drop unnecessary columns\n        |> drop(columns: [\"startMileage\", \"count\"])\n        // Add column related to charging, initielized with zero\n        |> map(fn: (r) => ({r with electricEnergyCharged: 0.0}))\n        // Add a column indicating the trip (process=0)\n        |> map(fn: (r) => ({r with process: 0}))\n\nchrgElMonth =\n    // Next create a table of charging events, starting form all charging events\n    chrgMonth\n        // drop unnecessary columns\n        |> drop(columns: [\"_field\", \"count\"])\n        //Rename the _value column to \"electricEnergyCharged\"\n        |> duplicate(column: \"_value\", as: \"electricEnergyCharged\")\n        |> drop(columns: [\"_value\"])\n        // Add columns found in the tripsAllEl table initialized with zero\n        |> map(fn: (r) => ({r with electricEnergyConsumed: 0.0}))\n        |> map(fn: (r) => ({r with fuelConsumed: 0.0}))\n        |> map(fn: (r) => ({r with traveltime: 0}))\n        |> map(fn: (r) => ({r with tripMileage: 0}))\n        // Add a column indicating the charging event (process=1)\n        |> map(fn: (r) => ({r with process: 1}))\n\ntripsAndCharging =\n    // Union streams with trips and charging tables\n    // Since both tables have the same set of columns, the resulting stream will be\n    // grouped into a single table\n    // The resulting table is not sorted with respect to _time\n    union(tables: [chrgElMonth, tripsAllEl])\n\ntripsAndChargingEl =\n    tripsAndCharging\n        // Sort with respect to _time to get the correct sequence of trips and charging events\n        |> sort(columns: [\"_time\"])\n        // The tag column will contain the cumuative sum of the process column\n        // Since trips have process=0 and charging have process=1, as a result\n        // the tag values for the charging events are larger by 1 compared to all related trips\n        |> duplicate(column: \"process\", as: \"tag\")\n        |> cumulativeSum(columns: [\"tag\"])\n        // Now, we create column tag3 to be used\n        // after grouping to check whether charging has been completed after a trip\n        |> duplicate(column: \"process\", as: \"tag3\")\n        // Now, in new column tag2, increment tag by 1 for all trips so that afterwards charging events\n        // and related trips have the same tag2 values\n        |> map(fn: (r) => ({r with tag2: if r.process == 0 then r.tag + 1 else r.tag}))\n        // We add a new column tripCount, which is used to count the number of trips\n        // associated with charging events for purely electric trips\n        |> map(fn: (r) => ({r with tripCount: if r.process == 0 then 1 else 0}))\n        // Now, we group the stream with respect to tag2 so that related trips and charging event\n        // are in the same table\n        |> group(columns: [\"tag2\"])\n        // Now, we sum tag3 within the different tables to see whether a set of trips\n        // has been followed by a complete charging process\n        |> cumulativeSum(columns: [\"tag3\"])\n        // Now, we sum up the relevant startistics data for all trips associated with the same charging event\n        |> cumulativeSum(\n            columns: [\n                \"electricEnergyCharged\",\n                \"electricEnergyConsumed\",\n                \"fuelConsumed\",\n                \"traveltime\",\n                \"tripMileage\",\n                \"tripCount\",\n            ],\n        )\n        // Only the last row in each table is kept which carries the sums for all trips preceding a charging event\n        |> tail(n: 1)\n        // Now, the stream can be ungrouped to have the results in a single table,\n        // one row for each charging event  associated with purely electric trips\n        |> group()\n        // Now, we keep only entries where no fuel was consumed in all trips preceding a charging event\n        // By that, we are sure that the charged energy was used for purely electric trips\n        |> filter(fn: (r) => r[\"fuelConsumed\"] == 0.0)\n        // Now, we filter trips after which charging is not yet completed\n        |> filter(fn: (r) => r[\"tag3\"] > 0)\n        // We add a column for counting the charging events for purely electric trips\n        |> map(fn: (r) => ({r with count: 1}))\n        // Unnecessary columns are dropped\n        |> drop(\n            columns: [\n                \"fuelConsumed\",\n                \"process\",\n                \"tag\",\n                \"tag2\",\n                \"tag3\",\n            ],\n        )\n\ntripsAndChargingElTotal =\n    tripsAndChargingEl\n        // Now, we sum up statistical data for the entire range\n        |> cumulativeSum(\n            columns: [\n                \"electricEnergyCharged\",\n                \"electricEnergyConsumed\",\n                \"traveltime\",\n                \"tripMileage\",\n                \"tripCount\",\n                \"count\",\n            ],\n        )\n        // ... and keep unly the last record containg the sums\n        |> last(column: \"count\")\n        // We add a column to be used as grouping key for later tableFind\n        |> map(fn: (r) => ({r with type: \"CCEl\"}))\n        |> group(columns: [\"type\"])\n\n// Check whether the result table has any entries\ntripsAndChargingElTotalExist = not isDropped(tables: tripsAndChargingElTotal)\n\ntripsAndChargingElTotalRec =\n    if tripsAndChargingElTotalExist then\n        tripsAndChargingElTotal\n            // Extract table from stream\n            |> tableFind(fn: (key) => key.type == \"CCEl\")\n            // Extract row from table\n            |> getRecord(idx: 0)\n    else\n        // Set result to nullRecord in case no data were found\n        nullRec\n\n// Extract statistics data from sum record\ntripsElectricChargeCycles =\n    if tripsAndChargingElTotalExist then tripsAndChargingElTotalRec[\"tripCount\"] else 0\nchargeCyclesElectric =\n    if tripsAndChargingElTotalExist then tripsAndChargingElTotalRec[\"count\"] else 0\nelectricEnergyChargedElectric =\n    if tripsAndChargingElTotalExist then\n        tripsAndChargingElTotalRec[\"electricEnergyCharged\"]\n    else\n        0.0\nelectricEnergyConsumedElectricChargeCycles =\n    if tripsAndChargingElTotalExist then\n        tripsAndChargingElTotalRec[\"electricEnergyConsumed\"]\n    else\n        0.0\nmileageElectricChargeCycles =\n    if tripsAndChargingElTotalExist then tripsAndChargingElTotalRec[\"tripMileage\"] else 0\n\n// Construct table with rows for the statistical data at the evaluation time\n// Evaluation time is the end of the evaluation period, e.g. end of a month\ntab =\n    array.from(\n        rows: [\n            {\n                _time: time,\n                _measurement: measurement,\n                tripsTotal: tripsTotal,\n                tripsElectric: tripsElectric,\n                tripsElectricChargeCycles: tripsElectricChargeCycles,\n                mileageTotal: mileageTotal,\n                mileageElectric: mileageElectric,\n                mileageElectricChargeCycles: mileageElectricChargeCycles,\n                traveltimeTotal: traveltimeTotal,\n                traveltimeElectric: traveltimeElectric,\n                fuelConsumed: fuelConsumed,\n                electricEnergyConsumedTotal: electricEnergyConsumedTotal,\n                electricEnergyConsumedElectric: electricEnergyConsumedElectric,\n                electricEnergyConsumedElectricChargeCycles:\n                    electricEnergyConsumedElectricChargeCycles,\n                chargeCyclesTotal: chargeCyclesTotal,\n                chargeCyclesElectric: chargeCyclesElectric,\n                electricEnergyChargedTotal: electricEnergyChargedTotal,\n                electricEnergyChargedElectric: electricEnergyChargedElectric,\n                vin: vin,\n            },\n        ],\n    )\n\n// Write data to InfluxDB bucket\ntab\n    |> to(\n        bucket: \"Car_Monthly\",\n        timeColumn: \"_time\",\n        measurementColumn: \"_measurement\",\n        tagColumns: [\"vin\"],\n        fieldFn: (r) =>\n            ({\n                \"tripsTotal\": r.tripsTotal,\n                \"tripsElectric\": r.tripsElectric,\n                \"tripsElectricChargeCycles\": r.tripsElectricChargeCycles,\n                \"mileageTotal\": r.mileageTotal,\n                \"mileageElectric\": r.mileageElectric,\n                \"mileageElectricChargeCycles\": r.mileageElectricChargeCycles,\n                \"traveltimeTotal\": r.traveltimeTotal,\n                \"traveltimeElectric\": r.traveltimeElectric,\n                \"fuelConsumed\": r.fuelConsumed,\n                \"electricEnergyConsumedTotal\": r.electricEnergyConsumedTotal,\n                \"electricEnergyConsumedElectric\": r.electricEnergyConsumedElectric,\n                \"electricEnergyConsumedElectricChargeCycles\":\n                    r.electricEnergyConsumedElectricChargeCycles,\n                \"chargeCyclesTotal\": chargeCyclesTotal,\n                \"chargeCyclesElectric\": chargeCyclesElectric,\n                \"electricEnergyChargedTotal\": electricEnergyChargedTotal,\n                \"electricEnergyChargedElectric\": electricEnergyChargedElectric,\n            }),\n    )"}}]