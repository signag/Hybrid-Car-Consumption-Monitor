[{"apiVersion":"influxdata.com/v2alpha1","kind":"Task","metadata":{"name":"elastic-hawking-35c001"},"spec":{"every":"5m","name":"HCCM_DechargeElectric","query":"//=============================================================================================================\n// This function analyzes the short term trips with respect to electric energy consumption\n// Keep in mind that this will be the energy consumption according to car display and not the real consumption\n// Only purely electric trips are considered\n// For each trip, a measurement entry is made in bucket Car_Consumption\n// In order to assure that this is done only after a charging process has been finished,\n// the drop of charging power is sensed\n//\n// This is limited to a single car, for which the Vehicle Identification Number must be spezified below\n//=============================================================================================================\nimport \"timezone\"\nimport \"date\"\nimport \"array\"\n\n\n\noption location = timezone.location(name: \"Europe/Berlin\")\n\n// !!! XXXXXXXXXXXXXXXXX ! Specify Vecicle Identification Number here !!!!!!!!!!!!!!!!!\nvin = \"XXXXXXXXXXXXXXXXX\"\n\n// For testing purposes, tStop may be set to a time shortly after a charging process has ended\n//tStop = 2023-03-22T12:30:00Z\ntStop = now()\n\n// This is the period used for sensing power drop for charging\n// It must be at least twice the sampling period used for device measurements\n// It must be less than the shortest possibe charging duration\nperiodSensing = 20m\n\n// This is the period used for gathering charging processes\nperiodProcesses = 2d\n\n// This is the threshold used for sensing the end of a charging process.\n// Typically half the charging power (~2 kW)\nchargingThreshold = 1000\n\n// ===================================================================================================\n// This function checks whether the chosen stop time is after the end of a charging period\n// ===================================================================================================\nchargingFinished = () => {\n    tStart = date.sub(from: tStop, d: periodSensing)\n\n    powerData =\n        from(bucket: \"Car_Charging\")\n            |> range(start: tStart, stop: tStop)\n            |> filter(fn: (r) => r[\"_measurement\"] == \"power\")\n            |> filter(fn: (r) => r[\"sublocation\"] == vin)\n\n    powerDataFirst =\n        powerData\n            |> first()\n    powerDataFirstRec =\n        powerDataFirst\n            |> findRecord(\n                fn: (key) => key._measurement == \"power\" and key._field == \"value\",\n                idx: 0,\n            )\n    p0 = powerDataFirstRec[\"_value\"]\n\n    powerDataLast =\n        powerData\n            |> last()\n    powerDataLastRec =\n        powerDataLast\n            |> findRecord(\n                fn: (key) => key._measurement == \"power\" and key._field == \"value\",\n                idx: 0,\n            )\n    p1 = powerDataLastRec[\"_value\"]\n\n    ret = if p0 > chargingThreshold and p1 < chargingThreshold then true else false\n\n    return ret\n}\n\n// ===================================================================================================\n// Analyze the short term trips to get the electric energy consumed\n// Here, only purely electric trips are considered\n// ===================================================================================================\nconsumptionElectricFromTrips =\n    () =>\n        {\n            tStart = date.sub(from: tStop, d: periodProcesses)\n\n            ret =\n                // Get all shortTerm trips for the given car within the given time range\n                from(bucket: \"Car_Trips\")\n                    |> range(start: tStart, stop: tStop)\n                    |> filter(fn: (r) => r[\"_measurement\"] == \"trip_shortTerm\")\n                    |> filter(fn: (r) => r[\"vin\"] == vin)\n                    // Get rid of unnecessary columns\n                    |> drop(\n                        columns: [\n                            \"_measurement\",\n                            \"_start\",\n                            \"_stop\",\n                            \"vin\",\n                            \"reportReason\",\n                            \"tripID\",\n                        ],\n                    )\n                    // Pivot with respect to _time to get a table with rows based on _time and data as columns\n                    |> pivot(rowKey: [\"_time\"], columnKey: [\"_field\"], valueColumn: \"_value\")\n                    // We need to make sure that the table is sorted with respect to _time\n                    |> sort(columns: [\"_time\"])\n                    // The Car_Trips bucket includes all partial trips for which data are accumulated into the latest.\n                    // Whereas WeConnect finally keeps only the latest trip of a group, we also keep the partial trips\n                    // as long as they have been received from WeConnect before the entire trip has been \"closed\"\n                    // by a gap of at least 2 hours\n                    // All partial trips of a trip have the same \"startMileage\"\n                    // We only need to keep the last one\n                    |> group(columns: [\"startMileage\"])\n                    |> tail(n: 1)\n                    // Now that we have a table of all trips within the relevant time range,\n                    // we only keep the purely electric ones.\n                    // tripMileage>0 is added because sometimes very short trips are registered with tripMileage=0\n                    // (WeConnect reports only integer mileage values). This would cause devision errors\n                    |> filter(fn: (r) => r[\"fuelConsumed\"] == 0 and r[\"tripMileage\"] > 0)\n                    // Some more columns are no longer required.\n                    // We only keep electricPowerConsumed\n                    |> drop(\n                        columns: [\n                            \"startMileage\",\n                            \"endMileage\",\n                            \"fuelConsumed\",\n                            \"traveltime\",\n                            \"tripMileage\",\n                        ],\n                    )\n                    // Now, we add the columns required for car_Consumption\n                    |> set(key: \"_measurement\", value: \"consumption\")\n                    |> set(key: \"process\", value: \"decharge\")\n                    |> set(key: \"source\", value: \"tripElectric\")\n                    |> set(key: \"vin\", value: vin)\n\n            return ret\n        }\n\ncf = chargingFinished()\n\n// This is a \"Null\" table which is required later in the Flux if statement\nconsNul =\n    array.from(\n        rows: [\n            {\n                _time: 1900-01-01T00:00:00Z,\n                _measurement: \"consumption\",\n                process: \"charge\",\n                source: \"home\",\n                vin: \"000000000000\",\n                electricPowerConsumed: 0.0,\n            },\n        ],\n    )\n\n// A consumption entry shall only be created after charging has been finished.\n// This guarantees that the latest trip is \"closed\"\n// and consumtion entries are not created for partial trips\ncons = if chargingFinished() then consumptionElectricFromTrips() else consNul\n\n// Now the entries in Car_Consumption for the relevant trips are created\ncons\n    |> to(\n        bucket: \"Car_Consumption\",\n        timeColumn: \"_time\",\n        measurementColumn: \"_measurement\",\n        tagColumns: [\"process\", \"source\", \"vin\"],\n        fieldFn: (r) => ({\"energy\": r.electricPowerConsumed}),\n    )"}}]